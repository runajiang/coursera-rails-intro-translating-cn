WEBVTT

1
00:00:00.112 --> 00:00:08.433
[MUSIC]

2
00:00:08.433 --> 00:00:11.370
Hi, and
welcome to lecture two of module two.
同学们好，欢迎来到第二课的第二讲

3
00:00:13.050 --> 00:00:16.340
In this lecture, we'll talk about
the Flow of Control structures in Ruby.
在这节里，我们会讲Ruby中的流程控制

4
00:00:16.340 --> 00:00:18.820
The if, the else, the case.
有if,else和case

5
00:00:18.820 --> 00:00:25.210
Ruby also adds two new ones, until and
unless, we'll talk about those.
Ruby还有两个新的，until和unless
我们今天会讲

6
00:00:25.210 --> 00:00:26.600
There's also the while and for.
还有while和for

7
00:00:26.600 --> 00:00:32.550
We'll talk about what is true and
what is false when comparing things.
我们会讲，当进行比较的时候，什么是真，什么是假

8
00:00:33.730 --> 00:00:36.100
And, what in the world
is this === operator?
还就，就是三个等号的运算符是什么

9
00:00:38.240 --> 00:00:42.850
So, the if, the elsif are probably
structures with which
if和elsif都常和

10
00:00:42.850 --> 00:00:45.340
a lot of us are familiar from
other programming languages.
我们熟悉的其他编程语言一起使用

11
00:00:46.510 --> 00:00:51.260
The difference is that in Ruby there's no
parentheses or curly braces when you find
不同的是，在Ruby里面，不用圆括号和花括号

12
00:00:51.260 --> 00:00:56.390
those, and you use end to
close the flow control block.
用end来作为控制流代码块的结束

13
00:00:56.390 --> 00:00:59.849
So whether it's just if statement,
or if and else statement,
所以，不管是只用if的语句
还是用if和else的语句

14
00:00:59.849 --> 00:01:02.476
you're always going to
have the end at the end.
你在结尾都要加上end

15
00:01:04.076 --> 00:01:09.450
So in this case you have the a variable
which gets assigned a value of five.
在这个例子里面，你有一个变量，赋值是5

16
00:01:09.450 --> 00:01:12.055
So when you assign it,
it's a single equals.
当你赋值时，用单等号

17
00:01:12.055 --> 00:01:14.905
When you're comparing,
it's a double equals and
当你进行比较时，用双等号

18
00:01:14.905 --> 00:01:18.775
in this case five matches the second
condition, so you print out a five.
在这个例子里面，5符合第二种情况，所以输出的是5

19
00:01:20.275 --> 00:01:24.645
Now Ruby also adds this
interesting keyword unless, and
Ruby里头还有unless，很有趣

20
00:01:24.645 --> 00:01:31.080
unless is basically if something
is not equal to something else.
Unless的用法基本上就是当一个东西不等于其他东西

21
00:01:31.080 --> 00:01:34.550
So, in this case,
a is five, unless a is six.
在这个例子里
a等于5，除非a等于6

22
00:01:34.550 --> 00:01:37.680
Do what you got to do, so
that's what's printed out.
否则该咋样咋样
那么输出的就是这个了

23
00:01:37.680 --> 00:01:38.420
A is not six.
a不是6

24
00:01:40.520 --> 00:01:42.530
Then there is your while loop, so
这是个while循环

25
00:01:42.530 --> 00:01:47.670
you have a variable,
which gets assigned a value of ten.
你有一个变量
赋值是10

26
00:01:47.670 --> 00:01:53.110
And while a is greater than nine, you keep
on executing the contents of the loop.
当a大于9的时候，你就执行这个的循环

27
00:01:54.680 --> 00:02:00.270
In this case, you're subtracting one from
a, every time going through the loop,
在这个例子里面，每进行一次循环，
你从a里头减去1

28
00:02:00.270 --> 00:02:04.470
so this will only execute
once because the second time,
所以这只会执行一次，因为当第二次的时候

29
00:02:04.470 --> 00:02:07.480
a is going to be not greater than nine.
a就不会大于9了

30
00:02:07.480 --> 00:02:09.894
So therefore the only output
from this loop is gonna be 10.
因此，这个循环唯一的输出将会是10

31
00:02:11.630 --> 00:02:19.400
Then you have a Ruby specific one which
is the opposite of while, it's until.
Ruby里面特有的，意思正好和while相反，就是until

32
00:02:19.400 --> 00:02:20.490
So a is nine.
a等于9

33
00:02:20.490 --> 00:02:27.280
Until a is greater than or equal to
ten keep on printing a value of nines,
除非a大于等于10，一直输出

34
00:02:27.280 --> 00:02:31.991
so this will also only execute
once because the second
这也只会执行一次，因为当循环第二次的时候

35
00:02:31.991 --> 00:02:37.550
time through the loop it's gonna be ten so
it will not execute.
数值将会是10
所以它不会执行

36
00:02:37.550 --> 00:02:44.280
Now Ruby gets even more expressive
in that there's this modifier form,
在下面这两个modifier form的例子里
Ruby就更贴近日常语言的表达了

37
00:02:44.280 --> 00:02:48.270
so the modifier form lets you
print things out in one line.
这是个if  modifier form
在modifier form里，你可以在一行代码里输入所有的条件

38
00:02:48.270 --> 00:02:51.890
So puts one liner if A is five and
如果a等于5，b等于0，就输出“one liner”

39
00:02:51.890 --> 00:02:56.720
B is zero, so
it almost reads like very natural English.
读起来就跟大白话一样

40
00:02:56.720 --> 00:02:58.640
And this applies to while as well.
对于while也一样

41
00:02:58.640 --> 00:03:03.990
So you have a variable called times two
which initially gets assigned to two,
你有一个变量名为“times_2” 
赋值是2

42
00:03:03.990 --> 00:03:10.138
and you keep on multiplying this variable
然后你把这个变量反复乘以2

43
00:03:10.138 --> 00:03:17.760
by two as long as this variable
times two is less than a hundred.
只要这个变量小于100
就一直乘以2

44
00:03:17.760 --> 00:03:20.688
So can you guess what
the answer to this one is?
那么你能猜出这个答案是多少吗？

45
00:03:23.397 --> 00:03:26.406
If you guessed 128, you are correct.
如果你的回答是128，那你就猜对了。

46
00:03:28.197 --> 00:03:30.800
Now, the next thing we'll talk
about is the true and false.
接着，我该讲true和false了。

47
00:03:30.800 --> 00:03:32.480
What is true and what is false in Ruby?
在Ruby里，什么是true，什么是false呢？

48
00:03:34.160 --> 00:03:38.220
As it turns out, the only things which
are false are gonna be your false
你会发现，只有当你犯错的时候

49
00:03:39.280 --> 00:03:44.480
literal or false object and nil object.
或者出现false对象或者nil对象的时候，才会出现false

50
00:03:44.480 --> 00:03:48.360
Everything else is true, so
if you're used to from other languages for
其他所有的都是true，
你用过其他语言里，0是false

51
00:03:48.360 --> 00:03:52.210
example that zero is false,
that's not true in Ruby.
Ruby里可不这样

52
00:03:52.210 --> 00:03:54.130
In Ruby, zero is true.
在Ruby里，0是true

53
00:03:54.130 --> 00:03:58.380
Or a false literal string is false?
那么字符串“false”是假吗？

54
00:03:58.380 --> 00:03:59.320
No it's not, it's true.
不是，它还是真。

55
00:04:00.640 --> 00:04:05.576
Or an empty string maybe you're used
to from some other languages that
在其他语言里 

56
00:04:05.576 --> 00:04:08.270
empty string is a false value.
空的字符串可能是false

57
00:04:08.270 --> 00:04:09.460
That's not true either.
在Ruby里它也是true

58
00:04:10.470 --> 00:04:15.910
So the only things which are false in Ruby
所以，在Ruby里面，

59
00:04:15.910 --> 00:04:22.160
are going to be a false literal or
a nil object.
唯一可能是false的，要么是个错误，或者是空对象

60
00:04:22.160 --> 00:04:25.040
Everything else is going to be true.
其他所有东西都是true

61
00:04:25.040 --> 00:04:29.160
Now if you're using a string literal,
for example, nil or
如果你现在在你的表达式里
使用字符串

62
00:04:29.160 --> 00:04:34.140
false or really any other string literal
in your if statement, you are going to get
例如，“nil”或者“false”

63
00:04:34.140 --> 00:04:39.340
a warning from an interpreter that
says string literal in condition.
你会从编译器得到一个警告

64
00:04:39.340 --> 00:04:44.590
Because you're not saying
if false equals false or
因为你没有在说false等于false

65
00:04:44.590 --> 00:04:48.760
doing any other comparisons, so if
the interpreter says to you really did you
或者进行比较
所以你的编译器在问你

66
00:04:48.760 --> 00:04:54.550
really mean to just say a string as
your condition of your if statement.
“真的吗？你真的是打算在if表达式里写个字符串作为条件么？”

67
00:04:54.550 --> 00:04:57.290
That's always gonna be true so
why would do that?
“那结果永远会是真，你这是逗我吗？”

68
00:04:57.290 --> 00:05:00.000
So it's almost like it's clueing
you in that there's an issue.
这时候它就在提示你，你可能犯了个错

69
00:05:02.490 --> 00:05:03.370
Triple equals.
我们来看三个等号

70
00:05:04.640 --> 00:05:08.520
So you're gonna see this in some cases.
你会在一些例子里看到这个

71
00:05:08.520 --> 00:05:12.570
So most of the time,
you should be using a double equals and
大多数时候，你会用两个等号

72
00:05:12.570 --> 00:05:18.130
that's what most Ruby objects use,
double equals.
Ruby里大多数对象都用两个等号

73
00:05:18.130 --> 00:05:23.110
But sometimes there is this interesting
implementation of a triple equals, and
但有时候，三个等号还有有妙用的

74
00:05:23.110 --> 00:05:26.500
triple equals basically is
a special kind of equals.
三个等号很特别

75
00:05:26.500 --> 00:05:31.410
So for example,
to jump straight into examples, you
我们来看看例子

76
00:05:31.410 --> 00:05:36.440
have a regular expression, and
regular expressions are outside
你有个正则表达式
其实跟你们这些菜鸟说正则表达式算超纲了

77
00:05:36.440 --> 00:05:40.840
the scope of this course but they're
pretty cool so you should check them out.
但是它很有趣，所以你们应该自学

78
00:05:40.840 --> 00:05:47.320
You have a regular expression,
sera, which is === to coursera.
你有个正则表达式sera
/sera/===courser

79
00:05:47.320 --> 00:05:49.030
Is it really equal?
他们相等吗？

80
00:05:49.030 --> 00:05:49.870
No, of course not.
当然不相等啦

81
00:05:49.870 --> 00:05:54.360
One is a string and one is a regular
expression, they're not really equal.
一个是字符串，一个是正则表达式
它们实际上不相等

82
00:05:54.360 --> 00:05:56.470
We're not even asking if they're equal.
我们也没有在问它们是不是相等

83
00:05:56.470 --> 00:06:01.840
But, it would be cool to say, does this
regular expression match a string literal,
但是，我们可以问，
这个正则表达式和字符串匹配吗？

84
00:06:01.840 --> 00:06:03.506
and that's what this triple equal does.
这就是三个等号的用法了

85
00:06:03.506 --> 00:06:09.600
Now, as you could see here,
看我的PPT

86
00:06:09.600 --> 00:06:15.310
a triple equals will also work if you're
just comparing a string to itself.
如果你一个字符串和它自己比较
三个等号同样适用

87
00:06:15.310 --> 00:06:20.910
That's also fine because triple equals
most of the time just delegates
因为大多数时候，三个等号其实发挥的是两个等号的作用

88
00:06:20.910 --> 00:06:25.860
to a double equals, so it's almost
like a super set of a double equals.
三个等号相当于两个等号的母集

89
00:06:27.090 --> 00:06:30.860
Another example is integer
class equal to 21.
另一个例子是，整数作为一个类，等于21

90
00:06:30.860 --> 00:06:35.550
Well no, one is integer class and
one is a value 21.
当然不等啦，一个是整数类
一个是数值21

91
00:06:35.550 --> 00:06:41.170
But it would be pretty cool to
know if this value, whatever
但是，如果你想知道一个数值

92
00:06:41.170 --> 00:06:46.410
value you're looking at is an integer,
and the triple equal lets you do that.
是不是整数
三个等号就可以做到

93
00:06:47.550 --> 00:06:50.090
Next, we'll talk about case expressions,
And
接下来，我们要说case表达式

94
00:06:50.090 --> 00:06:54.640
the case expressions
have two flavors in Ruby.
Ruby里面有两种case表达式的用法

95
00:06:54.640 --> 00:07:00.890
One flavor is very similar to your series
of if statements, if else statements.
一种和if语句，if else语句很类似

96
00:07:00.890 --> 00:07:06.370
So it's very similar to the if else
that we already saw in previous slides.
它和if else很相似，我们前面的幻灯片展示过了

97
00:07:06.370 --> 00:07:11.550
And this is just sort of a different
keyword, it's case instead of if else.
这个只是叫法不同
它是用case而不是if else

98
00:07:11.550 --> 00:07:13.420
So, that's the first flavor.
这就是第一种啦

99
00:07:13.420 --> 00:07:19.020
The second flavor is more interesting
in that you actually specify the target
第二种更有趣

100
00:07:19.020 --> 00:07:24.150
next to the case key word, and then
实际上你在case后指定了一个目标

101
00:07:24.150 --> 00:07:29.250
what happens is that each clause inside
the when gets compared to that target.
每一个when中的子句都会和目标进行比较

102
00:07:29.250 --> 00:07:31.020
And we see an example of
that in the next slide.
我们在下一页幻灯片里会看到例子

103
00:07:32.360 --> 00:07:35.900
And that's actually where the triple
equals, which we just covered in
这个就是三个等号登场的时候了

104
00:07:35.900 --> 00:07:40.140
the previous slide, comes in, it's also
called the case equality operator.
我们在前面的幻灯片讲过三个等号运算符
它也叫做case相等运算符

105
00:07:40.140 --> 00:07:44.490
So, when things are being compared for
当某个东西被用于和when子句比较时

106
00:07:44.490 --> 00:07:49.210
an each when clause, it's actually using
the triple equals operator for that.
实际上就是用三个等号的运算方式

107
00:07:50.450 --> 00:07:55.770
Now, just one last note on the case
expressions is that if you're
关于case表达式
还有最后一点

108
00:07:55.770 --> 00:08:00.360
used to the C style,
the C family of languages where
如果你习惯了C的风格

109
00:08:00.360 --> 00:08:05.200
you have a fall-through logic inside your
case statements, that's not the case.
在C里面，如果case后面没有遇到break语句就会一直往下执行
这种fall-through逻辑在Ruby里是不适用的

110
00:08:05.200 --> 00:08:10.440
Ruby, one case, the only case that
actually matches gets executed and
在Ruby里，只有唯一匹配的case才会被执行

111
00:08:10.440 --> 00:08:11.110
no other cases.
其他的case是不会的

112
00:08:12.820 --> 00:08:17.170
So to show you an example of
the two flavors we just discussed,
给大家看看我们刚才说的两类case表达式的用法

113
00:08:17.170 --> 00:08:18.830
the first flavor is very simple.
第一种很简单

114
00:08:18.830 --> 00:08:23.400
You have, for example a variable,
but then the actual
你有一个变量

115
00:08:23.400 --> 00:08:28.140
comparisons inside the case have
nothing to do with that variable.
case里面的比较和变量没有一毛钱关系

116
00:08:28.140 --> 00:08:31.560
I mean you can compare that variable, you
could compare other statements, you could
这里面的子句可以和变量比较
也可以和其他不相关的语句比较

117
00:08:31.560 --> 00:08:35.670
have a default statement, really has
nothing to do with the actual variable.
你可以有一个默认的语句
总之这些子句和变量真的没关系

118
00:08:35.670 --> 00:08:36.830
It's almost like an if else.
很像if else有没有

119
00:08:36.830 --> 00:08:38.300
That's the first flavor.
这是第一种

120
00:08:38.300 --> 00:08:45.050
The second flavor, you have the actual
target right next to the case
第二种方法，你的目标就在case之后

121
00:08:45.050 --> 00:08:49.395
so every condition in the case
所以在case里的每一种情况

122
00:08:49.395 --> 00:08:54.870
implicitly compares
itself to actual targets.
都和实际的目标比较

123
00:08:54.870 --> 00:08:56.660
In this case, you have
在这个case里，

124
00:08:57.920 --> 00:09:03.160
regular expression doing the triple
equals, that's what case uses,
你有个正则表达式
这是case的用法

125
00:09:03.160 --> 00:09:08.980
uses the triple equals operator to
compare itself to a name target.
用三个等号运算符来将正则表达式与目标进行比较

126
00:09:11.880 --> 00:09:15.710
For loop I did say we're going
to talk about it, but I lied.
我前面跟你们说我要讲for循环
我骗你们的，哈哈

127
00:09:17.140 --> 00:09:25.050
For loop is hardly used in Ruby and
preference is given to each and times.
在Ruby里面基本不用for循环
大家比较喜欢用each和times


128
00:09:25.050 --> 00:09:27.530
So the times we already
saw all the way back
关于times的用法
在上节课我们就讲了

129
00:09:29.060 --> 00:09:34.040
in beginning of the last lecture,
and we also going to see each, and
接下来我们会讲each

130
00:09:34.040 --> 00:09:39.210
I'll talk about both of these when we
talk about blocks, which is coming up.
下一节讲block的时候我们会连带这一起讲

131
00:09:40.980 --> 00:09:46.290
Now if you do want to see an example
of a for loop, Ruby does have one.
如果你真的想看for循环的例子
Ruby倒是有一个

132
00:09:46.290 --> 00:09:51.820
So you have a for some integer in a range,
你有一个for，在一个区间里的整数

133
00:09:51.820 --> 00:09:55.880
a range again is a data type
which we haven't talked about, so
区间是一种数据形式
我们还没说过

134
00:09:55.880 --> 00:10:00.880
you could say for
i in this range of 0 to 2,
你可以说，在这个for里，i在0到2之间

135
00:10:00.880 --> 00:10:05.250
print out the variable i and
you have 0, 1, and 2.
输入i的话，
你会得到0，1和2

136
00:10:05.250 --> 00:10:08.440
So this is your typical for
loop, but like I said, for
这就是一个典型的for循环
但是我刚才也说

137
00:10:08.440 --> 00:10:12.090
loops exist in Ruby, but
they are not used much.
Ruby里面的确有for循环
但是基本上不使用

138
00:10:13.980 --> 00:10:17.170
So in summary, there are lots
of options for flow of control.
总结一下
流程控制有很多种方法

139
00:10:17.170 --> 00:10:24.030
You have if, else, the cases,
the while loops, the until, the unless.
你可以用if，else，case，while循环，until，unless

140
00:10:24.030 --> 00:10:26.120
And then you also have the modifier form,
你还可以用modifier form

141
00:10:26.120 --> 00:10:29.620
which is a very interesting way
to be very expressive in Ruby.
在Ruby里面，这是个非常有趣的表达方法

142
00:10:29.620 --> 00:10:33.829
And what you should remember
is that non-nil and
你要记住的是
如果一个值既不是nil也不是false

143
00:10:33.829 --> 00:10:37.740
non-false values are always gonna be true.
那么这个值永远是true

144
00:10:37.740 --> 00:10:44.180
And the only things which are gonna be
false are your false and your nil object.
唯一可能出现false值的情况是
你出错了，或者是nil值

145
00:10:44.180 --> 00:10:45.270
So what's next?
下一节

146
00:10:45.270 --> 00:10:48.155
Next we're gonna talk about
the functions and the methods in Ruby.
我们要讲函数和方法
